=============================================================================================================================================
| # Title     : Exim Vulnerability Scanner                                                                                                  |
| # Author    : indoushka                                                                                                                   |
| # Tested on : windows 11 Fr(Pro) / browser : Mozilla firefox 147.0.3 (64 bits)                                                            |
| # Vendor    : https://www.exim.org/                                                                                                       |
=============================================================================================================================================

[+] Summary    : This Python-based tool is a defensive security scanner designed to assess potential vulnerabilities in mail servers running Exim.

[+] The scanner performs the following functions:

Connects to a target SMTP service (default port 25)

Retrieves and analyzes the server banner to detect the Exim version

Compares the detected version against known vulnerable ranges

Checks for risky SMTP features such as:

STARTTLS support

PIPELINING

AUTH mechanisms

DSN support

BDAT (CHUNKING)

It evaluates exposure to multiple known vulnerabilities including:

CVE-2020-28007 through CVE-2020-28026

CVE-2021-27216

The tool does not exploit vulnerabilities, but identifies potentially affected versions and misconfigurations based on version and feature analysis.

[+] POC : 

#!/usr/bin/env python3
"""
Usage: python3 exim.py <target> [port]
"""

import socket
import ssl
import sys
import time
import argparse
from datetime import datetime

class EximVulnerabilityScanner:
    def __init__(self, target, port=25, timeout=10):
        self.target = target
        self.port = port
        self.timeout = timeout
        self.banner = None
        self.version = None
        self.vulnerabilities = []
        
    def connect(self, use_ssl=False):
        """Establish a connection to the server"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, self.port))
            
            if use_ssl:
                context = ssl.create_default_context()
                sock = context.wrap_socket(sock, server_hostname=self.target)
                
            return sock
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return None

    def get_banner(self):
        """Retrieve server banner and determine version"""
        sock = self.connect()
        if not sock:
            return False
        
        try:
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            self.banner = banner

            if "Exim" in banner:
                import re
                version_match = re.search(r'Exim (\d+\.\d+)', banner)
                if version_match:
                    self.version = version_match.group(1)
                    print(f"[+] Exim version detected: {self.version}")
                else:
                    print(f"[+] Exim detected (unspecified version)")
                    
                print(f"[+] Banner: {banner}")
                return True
            else:
                print(f"[-] This is not an Exim server")
                print(f"    Banner: {banner}")
                return False
                
        except Exception as e:
            print(f"[-] Error reading banner: {e}")
            return False
        finally:
            sock.close()

    def check_vulnerable_version(self):
        """Check for vulnerable versions"""
        if not self.version:
            print("[-] Cannot determine version")
            return False
            
        version_float = float(self.version)
        
        print("\n[*] Version Analysis:")

        if version_float < 4.92:
            print("  [!] CVE-2020-28020: Integer Overflow (RCE)")
            print("      Affected versions: < 4.92")
            print("      Impact: Remote Code Execution")
            self.vulnerabilities.append({
                'cve': 'CVE-2020-28020',
                'affected_versions': '< 4.92',
                'type': 'RCE',
                'description': 'Integer overflow in receive_msg()'
            })

        if 4.90 <= version_float < 4.94:
            print("  [!] CVE-2020-28018: Use-after-free (RCE)")
            print("      Affected versions: 4.90 - 4.93")
            print("      Impact: Remote Code Execution (with OpenSSL)")
            self.vulnerabilities.append({
                'cve': 'CVE-2020-28018',
                'affected_versions': '4.90 - 4.93',
                'type': 'RCE',
                'description': 'Use-after-free in tls-openssl.c'
            })

        if version_float == 4.94:
            print("  [!] CVE-2021-27216: Arbitrary File Deletion (LPE)")
            print("      Affected versions: 4.94")
            print("      Impact: Delete any file on the system")
            self.vulnerabilities.append({
                'cve': 'CVE-2021-27216',
                'affected_versions': '4.94',
                'type': 'LPE',
                'description': 'Arbitrary file deletion via -oP'
            })

        if version_float >= 4.88:
            print("  [!] CVE-2020-28023: Out-of-bounds Read")
            print("      Affected versions: 4.88 - 4.94")
            print("      Impact: Information Disclosure")
            self.vulnerabilities.append({
                'cve': 'CVE-2020-28023',
                'affected_versions': '4.88 - 4.94',
                'type': 'Info Disclosure',
                'description': 'Out-of-bounds read in smtp_setup_msg()'
            })

        if version_float >= 4.89:
            print("  [!] CVE-2020-28022: Out-of-bounds Read/Write")
            print("      Affected versions: 4.89 - 4.94")
            print("      Impact: Potential RCE")
            self.vulnerabilities.append({
                'cve': 'CVE-2020-28022',
                'affected_versions': '4.89 - 4.94',
                'type': 'Potential RCE',
                'description': 'Out-of-bounds read and write in extract_option()'
            })

        if version_float >= 4.88:
            print("  [!] CVE-2020-28019: Failure to reset function pointer")
            print("      Affected versions: 4.88 - 4.94")
            print("      Impact: Denial of Service (DoS)")
            self.vulnerabilities.append({
                'cve': 'CVE-2020-28019',
                'affected_versions': '4.88 - 4.94',
                'type': 'DoS',
                'description': 'Failure to reset function pointer after BDAT error'
            })
            
        return True

    def test_starttls(self):
        """Test STARTTLS support"""
        print("\n[*] Testing STARTTLS...")
        sock = self.connect()
        if not sock:
            return False
            
        try:

            sock.recv(1024)
            sock.send(b"EHLO scanner\r\n")
            response = sock.recv(4096).decode()
            
            if "STARTTLS" in response:
                print("  [+] Server supports STARTTLS")

                sock.send(b"STARTTLS\r\n")
                response = sock.recv(1024).decode()
                
                if "220" in response:
                    print("  [+] STARTTLS is available")

                    try:
                        context = ssl.create_default_context()
                        ssl_sock = context.wrap_socket(sock, server_hostname=self.target)
                        print("  [+] TLS connection established successfully")

                        if self.version and 4.90 <= float(self.version) < 4.94:
                            print("  [!] Server may be vulnerable to CVE-2020-28018")
                            
                    except Exception as e:
                        print(f"  [-] TLS connection failed: {e}")
                else:
                    print("  [-] STARTTLS is not available")
            else:
                print("  [-] Server does not support STARTTLS")
                
        except Exception as e:
            print(f"  [-] Error: {e}")
        finally:
            try:
                sock.close()
            except:
                pass
                
    def test_pipelining(self):
        """Test PIPELINING support"""
        print("\n[*] Testing PIPELINING...")
        sock = self.connect()
        if not sock:
            return
            
        try:
            sock.recv(1024)

            sock.send(b"EHLO scanner\r\n")
            response = sock.recv(4096).decode()
            
            if "PIPELINING" in response:
                print("  [+] Server supports PIPELINING")
                print("  [!] This may increase the attack surface for some vulnerabilities")

                if self.version and 4.90 <= float(self.version) < 4.94:
                    print("  [!] CVE-2020-28018: Combining TLS and PIPELINING may be dangerous")
            else:
                print("  [-] Server does not support PIPELINING")
                
        except Exception as e:
            print(f"  [-] Error: {e}")
        finally:
            sock.close()

    def test_auth_mechanisms(self):
        """Test Authentication Mechanisms"""
        print("\n[*] Testing Authentication Mechanisms...")
        sock = self.connect()
        if not sock:
            return
            
        try:
            sock.recv(1024)

            sock.send(b"EHLO scanner\r\n")
            response = sock.recv(4096).decode()
            
            auth_lines = [line for line in response.split('\n') if 'AUTH' in line]
            
            if auth_lines:
                print("  [+] Supported Authentication Mechanisms:")
                for line in auth_lines:
                    print(f"    {line.strip()}")

                print("  [!] CVE-2020-28021: Server may be vulnerable to line injection")
                print("      if it allows user authentication")
            else:
                print("  [-] No authentication mechanisms found")
                
        except Exception as e:
            print(f"  [-] Error: {e}")
        finally:
            sock.close()

    def test_dsn_support(self):
        """Test DSN support"""
        print("\n[*] Testing DSN (Delivery Status Notification)...")
        sock = self.connect()
        if not sock:
            return
            
        try:
            sock.recv(1024)

            sock.send(b"EHLO scanner\r\n")
            response = sock.recv(4096).decode()
            
            if "DSN" in response:
                print("  [+] Server supports DSN")
                print("  [!] CVE-2020-28026: Server may be vulnerable if DSN is enabled")
            else:
                print("  [-] DSN not supported")
                
        except Exception as e:
            print(f"  [-] Error: {e}")
        finally:
            sock.close()

    def test_bdat_command(self):
        """Test BDAT command support"""
        print("\n[*] Testing BDAT command...")
        sock = self.connect()
        if not sock:
            return
            
        try:
            sock.recv(1024)

            sock.send(b"EHLO scanner\r\n")
            response = sock.recv(4096).decode()
            
            if "CHUNKING" in response:
                print("  [+] Server supports BDAT (CHUNKING)")
                print("  [!] CVE-2020-28019: Server may be vulnerable to DoS via BDAT")
            else:
                print("  [-] BDAT not supported")
                
        except Exception as e:
            print(f"  [-] Error: {e}")
        finally:
            sock.close()

    def generate_report(self):
        """Generate final report"""
        print("\n" + "="*60)
        print("Exim Security Scan Report".center(60))
        print("="*60)
        
        print(f"\nTarget: {self.target}:{self.port}")
        print(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        if self.banner:
            print(f"\nBanner: {self.banner}")
        else:
            print("\n[-] Banner not retrieved")
            
        if self.version:
            print(f"Version: {self.version}")

            version_float = float(self.version)
            if version_float >= 4.95:
                print("\n[+] Version is up-to-date and relatively secure")
            elif version_float >= 4.94:
                print("\n[!] Version is outdated and contains serious vulnerabilities")
                print("    Immediate update to 4.95 or newer is recommended")
            else:
                print("\n[!] Version is very old and vulnerable to multiple exploits")
                print("    Update immediately!")
        else:
            print("\n[-] Version could not be determined")

        if self.vulnerabilities:
            print("\nPotential Vulnerabilities:")
            for vuln in self.vulnerabilities:
                print(f"  • {vuln['cve']}: {vuln['description']}")
                print(f"    Type: {vuln['type']}")
                print(f"    Affected Versions: {vuln['affected_versions']}")
        else:
            print("\n[-] No specific vulnerabilities detected")
            
        print("\nRecommendations:")
        print("  • Update Exim to version 4.95 or newer")
        print("  • Disable unnecessary features")
        print("  • Continuously monitor server logs")
        print("  • Apply the principle of least privilege")
        
        print("\n" + "="*60)

def main():
    parser = argparse.ArgumentParser(description='Exim Vulnerability Scanner')
    parser.add_argument('target', help='Target IP or hostname')
    parser.add_argument('-p', '--port', type=int, default=25, help='Port number (default: 25)')
    parser.add_argument('-t', '--timeout', type=int, default=10, help='Timeout in seconds (default: 10)')
    
    args = parser.parse_args()
    
    print("="*60)
    print("Exim Vulnerability Scanner".center(60))
    print("For Defensive Use Only".center(60))
    print("="*60)
    
    scanner = EximVulnerabilityScanner(args.target, args.port, args.timeout)

    if not scanner.get_banner():
        print("\n[!] The server might not be an Exim mail server")
        response = input("Do you want to continue the scan? (y/n): ")
        if response.lower() != 'y':
            return
    scanner.check_vulnerable_version()
    scanner.test_starttls()
    scanner.test_pipelining()
    scanner.test_auth_mechanisms()
    scanner.test_dsn_support()
    scanner.test_bdat_command()
    scanner.generate_report()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[-] Scan cancelled")
        sys.exit(0)
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        sys.exit(1)
		
Greetings to :======================================================================
jericho * Larry W. Cashdollar * r00t * Hussin-X * Malvuln (John Page aka hyp3rlinx)|
====================================================================================